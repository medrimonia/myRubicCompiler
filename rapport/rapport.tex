\documentclass[12pt]{article}

\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}

\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{color}
\usepackage{listings}
\lstset{language=SQL, frame=shadowbox, rulesepcolor=\color{white}}

\geometry{margin=2cm}


\begin{document}

\thispagestyle{empty}
%\noindent\includegraphics[width=0.25\textwidth]{enseirb-matmeca}

\vspace{\stretch{1}}

\begin{center}
	\Huge{\textbf{Rapport de projet de Compilation :}}
\end{center}

\vspace{\stretch{2}}

\begin{tabular}{r@{:~}l}
	\textbf{Auteur} & \textit{HOFER Ludovic}\\
  \textbf{Encadrant} & \textit{BARTHOU Denis}\\
\end{tabular}

\vspace{\stretch{1}}

\begin{center}Deuxième année, filière informatique

	Date : \today
\end{center}

\newpage

\section{Introduction}
Ce travail s'inscrit dans le cadre du cours de compilation dispensé à
l'enseirb-matmeca. Le but qui nous a été donné est de réaliser un compilateur
capable de transformer un programme écrit en rubic\footnote{Une version
simplifiée du langage Ruby} en une version du programme respectant les
spécifications du langage llvm\footnote{http://llvm.org/}.\\

Afin de nous faciliter le travail, l'analyse lexicale et syntaxique étaient
déjà disponibles sous la forme d'un fichier lex et d'un fichier yacc. Le
travail à fournir était donc plus axé sur la génération de code.\\

Outre le travail classique à fournir lors de l'implémentation d'un
compilateur pour un langage simplifié, plusieurs difficultés techniques
étaient présentes dans ce langage :

\begin{itemize}
\item Résolution du types des variables\footnote{Le type de celles-ci
  n'étant pas fourni, il est nécessaire de le déterminer à la compilation}
\item Gestion de la surcharge\footnote{Il est possible d'écrire plusieurs
  fonctions ayant le même nom, si elles diffèrent par leurs paramètres}
\item Gestion des classes\footnote{rubic étant un langage objet,
  il doit être possible de déclarer des classes et de les utiliser}
\item Génération de fonction ambigues\footnote{Lorsque les types de certains
  paramètres d'une fonction ne peuvent pas être résolus directement, il faut
  générer le code de plusieurs fonctions pour une seule définition}
\end{itemize}

Certaines de ces tâches étant d'une complexité non négligeable, il est
intéressant de noter comment elles ont été traitées ainsi que les raisons
de certains choix d'implémentation.\\

Au vu de l'ampleur de la tâche\footnote{Bien que ce soit le projet du premier
semestre sur lequel j'aie le plus travaillé, PFA excepté, je suis loin de
remplir de façon satisfaisante les objectifs qui ont été donnés.}, il m'a
semblé évident qu'un minimum d'organisation était nécessaire et que le choix
des méthodes de développement utilisées était primordial. La méthode utilisée
sera donc détaillée dans ce document.\\

Ayant déjà fait un travail\footnote{http://code.google.com/p/my-c-compiler/}
un peu similaire lors de ma scolarité à l'université de Bordeaux 1
\footnote{Le projet mentionné ici ne comportait pas les mêmes difficultés,
puisque le langage d'entrée était typé et ne permettait pas la surcharge.},
j'ai décidé de rester en c plutôt que de choisir le java\footnote{C'est le
choix que j'avais pour mon projet précédent, y utilisant jflex et cup.}. Les
principales difficultés engendrées par ce changement étaient les suivantes :

\begin{itemize}
\item L'utilisation de type abstrait de données\footnote{En java ceux-ci sont
déjà fournis, alors qu'en c, il est plus difficile de trouver la version
adaptée, j'ai donc écrit mes conteneurs moi-même.}
\item La gestion de la mémoire\footnote{Celle-ci étant de loin plus facile en
java.}
\end{itemize}

\section{Organisation du travail}

Sachant pertinemment que j'avais peu de chance d'arriver à remplir toutes les
exigences du projet en étant seul dans mon groupe et qu'il m'était difficile
d'appréhender directement tout le contenu du projet, j'ai préféré m'orienter
vers une approche de construction progressive du projet en ajoutant une à une
des fonctionnalité plutôt que de concevoir le projet en entier puis de passer
à une phase d'implémentation et de me retrouver coincé par des problèmes que
je n'avais pas envisagé.

\subsection{Développement brique par brique}
Le principe de l'ordre de développement choisi est assez simple, il consiste
à se fixer comme objectif la compilation d'un certain programme rubic
\footnote{En commençant évidemment par les plus simples.}, puis d'ajouter le
code manquant. Ainsi, le développement alterne à un rythme assez élevé les
phases de conception, de codage et de débuguage.\\

Cette méthode présente les avantages suivants :
\begin{itemize}
\item Une stimulation par une visualisation de progression aisée.
\item L'assurance qu'à la fin du projet, la conception sera à peu près au
  même niveau que l'implémentation.
\item La conception d'une notion complexe se basera sur l'implémentation de
  notions plus simples au lieu de se baser sur la conception de celle-ci.
\end{itemize}

Cependant, elle possède aussi des désavantages :
\begin{itemize}
\item L'ajout de nouvelles fonctionnalités peut obliger à retravailler de
  manière plus ou moins marquée le code existant.
\item En implémentant de nouvelles fonctionnalités, il est possible de
  dégrader celles déjà présentes sans s'en apercevoir.
\end{itemize}

Afin de pallier le premier problème, j'ai essayé de garder à l'esprit les
fonctionnalités complexes lorsque j'implémentais celles qui étaient plus
simple.\\

Pour éviter d'introduire des bugs lors du développement, j'ai fait évoluer
en parallèle un module de tests me permettant d'assurer la transformation de
code rubic en code exécutable.

\subsection{Tests}

Ma première approche des tests a été de chercher à maitriser la
transformation de code llvm en exécutable, cette partie n'étant pas
directement reliée au projet, il n'était pas nécessaire d'écrire le moindre
code pour celle-ci. Il suffisait de prendre en main les outils de compilation
existants, j'en ai profité pour ajouter les instructions génériques
nécessaires dans le Makefile afin de transformer facilement n'importe quel
fichier rubic en exécutable.\\

Une fois que le projet avait un peu plus pris forme, j'ai écrit un script
permettant de compiler tous les fichiers {\em.rubic}, de les lancer et de
vérifier que leur valeur de retour est bien égale à zéro. Ceci permet de bien
s'assurer de ne pas avoir introduit de bug.\\

Dans un second temps, un affichage du nombre de tests total et du nombre de
tests ayant compilé a été ajouté afin de déceler plus facilement si des
problèmes surviennent à la compilation des fichiers rubics.

\section{Les conteneurs}

Étant donné qu'une grande partie des données que le compilateur doit stocker
ne sont pas de taille fixée, il semble évident qu'utiliser uniquement des
tableaux ne sera pas adapté. Les conteneurs génériques étant difficiles à
trouver en c, j'ai donc implémenté les miens en essayant de les rendre
réutilisable afin de pouvoir m'en servir à nouveau pour d'autres projets.

\subsection{Hashmap}
Ce choix s'est imposé comme étant indispensable pour la gestion du stockage
de différentes données telles que les fonctions ou les variables. Il est
beaucoup plus aisé d'utiliser une structure permettant un accès et une
insertion rapide.\\

Dans une première approche, je souhaitais effacer automatiquement les clés et
les objets contenus, mais je me suis rapidement rendu compte qu'il valait
souvent mieux laisser l'utilisateur du conteneur faire ses free.\\

J'ai aussi du ajouter un moyen d'itérer sur ces conteneurs afin d'allouer
toutes les variables par exemple.\\

La possibilité d'ajuster la taille d'une hashmap a été laissée de côté
pour l'instant, les problèmes de temps d'accès n'étant pas cruciaux dans le
cadre actuel.

\subsection{Dictionnary}
Comme de nombreuses Hashmap auraient prit comme clé des chaînes de caractère,
j'ai préféré créer un conteneur qui simplifie les pointeur renvoyés et
qui fournit dans le même temps une fonction de hachage et une fonction
vérifiant l'égalité de deux chaînes de caractère tout en respectant le
prototype souhaité par les Hashmap.

\subsection{LinkedList}
Afin de simuler différentes données n'ayant pas de clé, mais dont le nombre
reste tout de même inconnu\footnote{La possibilité de créer de nouveau types
étant offerte en rubic via les classes, le nombre de types possibles est
inconnu par exemple.}, j'ai décidé de choisir des listes chaînées, celles-ci
étant relativement simple à implémenter et agréable d'utilisation. De plus,
il m'était nécessaire d'avoir une structure semblable, afin de garantir que
les insertions dans la hashmap fonctionnent.

\subsection{La structure arborescente}
Étant donné que l'on parle d'arbre syntaxique, il est assez naturel que j'ai
utilisé des arbres pour représenter le résultat de l'analyse syntaxique. Fait
pratique, comme tout noeud représente un arbre et que je n'avais pas besoin
de retirer des noeuds de l'arbre, il ne m'était pas nécessaire de fournir
de nombreuse primitives pour le maniement de cette structure. Au contraire,
je l'ai gardée assez explicite avec de nombreux champs spécifique faisant
partie des noeuds, cela m'a permit une écriture simplifiée dans certains cas.

\subsection{DoublyLinkedList}
Estimant nécessaire d'avoir à disposition une liste pouvant être parcourue
dans les deux sens, j'ai ajouté à ces conteneurs une implémentation de liste
doublement chaînée utilisant le principe de sentinelles.\\

Cependant, avec le recul, je me demande s'il était réellement nécessaire de
disposer de ces fonctionnalités ou si une liste chaînée n'aurait pas suffit
pour gérer le polymorphisme.

\section{Les aspects de la compilation}
Compiler un programme rubic en programme llvm pouvant être perçu comme un
ensemble de fonctionnalités à implémenter et donc comme un ensemble de
problèmes. Dans cette optique, je vais expliquer les méthodes utilisées pour
chacun des sous-problèmes.\\

Il est à noter qu'afin de simplifier un maximum les problèmes, j'ai commencé
par considérer que le seul type accepté était les int, ainsi toutes mes
opérations pouvaient être codée plus facilement.

\subsection{Les allocations mémoires}
Afin d'allouer de la mémoire à toutes les différentes variables qui en
nécessitaient, j'ai décidé de simpler allouer l'espace à toutes les
variables au début de chaque fonction, cependant, je n'ai pas vérifié si
ces espaces mémoires étaient bien libérés à la sortie de chaque fonction.

\subsection{Les fonctions}
Pour traiter les fonctions, il était nécessaire de distinguer leurs
paramètres des simples variables locales, les premiers appartennant à la
signature tandis que les secondes n'ont qu'une visibilité locale.\\

Traité d'une manière similaire aux variables, les fonctions étaient
simplement ajoutées à un dictionnaire et pour déterminer si l'appel était
valide, il fallait simplement vérifier si la fonction était présente dans le
dictionnaire et si les paramètres correspondaient à ce qui était attendu.

\subsubsection{Les built-in}
L'utilisation de certains {\em built-in} comme {\em puts} nécessitait que les
fonctions soient déclarées, même si elles n'étaient pas définies. Afin que
cela reste le plus simple pour l'utilisateur, j'ai simplement ajouté un
dictionnaire contenant les {\em built-in}, ainsi qu'un autre contenant les
{\em built-in} utilisé\footnote{Celui-ci étant évidemment initialisé comme
vide}. Ainsi à chaque fois qu'une utilisation de {\em built-in} était
détectée, il était assuré que le built-in serait déclaré dans le fichier
généré. Cette procédure m'a permit de garantir que si de nouveaux
{\em built-in} étaient ajouté, il n'y aurait pas un nombre de lignes inutiles
grandissant au début de chaque fichier généré.

\subsection{Les opérateurs}


\subsection{Première gestion des types}
Afin de travailler dans un environnement simplifié, j'ai commencé par
considérer comme types possibles uniquement les int et les chaînes de
caractère, l'ambiguité entre ces deux types étant peu probable. Ainsi,
j'ajoutai malgré tout la prise en charge de plusieurs types, sans pour autant
m'heurter à des problèmes plus complexes\footnote{L'ajout de float engendrait
en effet une obligation de traiter (de manière plus ou moins complète) le cas
du polymorphisme}.

\subsubsection{Des listes de types autorisés}
Afin de déterminer de quel type est une variable, j'ai pensé qu'il était plus
simple de commencer par affirmer qu'elle pouvait être de tous les types
connus, puis de restreindre ces types lorsqu'une contrainte était découverte
\footnote{Que ce soit sous la forme d'un opérateur, d'un appel à une fonction
ou n'importe quel autre type de contrainte}. Lorsqu'un nouveau noeud était
créé, les types qui lui étaient autorisé dépendait donc du type de ses fils.
Le nouveau noeud exerçait aussi une contrainte sur les noeuds qui étaient
directement ses fils, mais pas sur toute sa descendance\footnote{Ceci afin
d'éviter de faire exploser la complexité. La compilation étant sensé être une
opération assez rapide.}.

\subsubsection{Contraintes lors du parcours de l'arbre}
En parcourant l'arbre plusieurs fois, il devenait donc possible de répéter
les contraintes plusieurs fois et d'ainsi affiner le résultat dans des cas
particuliers un peu litigieux. Cependant, étant donné qu'il est difficile
de borner le nombre de passages nécessaires, un seul passage était effectué
au début\footnote{Les changements seront plus détaillés lors de la phase
gestion du polymorphisme}. Le choix pris à ce moment était de déclencher une
erreur de compilation lorsque le type des paramètres d'une fonction n'étaient
pas déterminés après le premier passage.

\subsubsection{Choix du type lors de la génération de code}
Lors de la passe sur l'arbre servant à effectuer la génération de code,
il m'était nécessaire de décider quel type allait être utilisé pour le noeud,
étant donné que celui-ci déterminait le nom de l'opération à appliquer
\footnote{add, fadd ou icmp, fcmp etc...}. Pour ceci, j'ai décidé d'utiliser
une logique extrêment simple, s'il restait un seul type alloué, c'est celui
qui était utilisé et dans le cas contraire, il y avait une erreur de
compilation\footnote{Le type de la variable étant ambigu ou impossible
à définir}.

\subsection{Les conditionnelles}
Afin d'implémenter les structures de code conditionnelles\footnote{blocs if
et blocs if/else}, il a été évidemment nécessaire de supporter les booléens,
ce qui s'est fait assez facilement, puisqu'avec la manière dont j'avais
implémenté mon gestionnaire de type, cela ne représentait que quelques lignes
à ajouter.\\

Afin de simplifier un peu l'implémentation, j'ai décidé que les deux formes
de blocs conditionnels seraient représentés par le même noeud. Le contenu de
celui-ci serait simplement représenter par trois noeuds, la condition, la
liste d'instructions à exécuter dans le cas vrai et celle dans le cas faux
\footnote{Cette dernière sera donc mise à nulle dans les cas où le elsen'est
pas utilisé}\\

La présence des conditionnelles a aussi grandement facilité

\subsection{Les boucles}

\subsubsection{La boucle \em{while}}

\subsubsection{La boucle \em{for}}

\subsection{Gestion du polymorphisme}

\subsection{La gestion des classes}

\section{La gestion de la mémoire}

\section{Conclusion}


\end{document}
